/**
 * Created by Andy Likuski on 2017.08.30
 * Copyright (c) 2017 Andy Likuski
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

import {v} from 'rescape-validate';
import PropTypes from 'prop-types';

module.exports.CYCLE_API_KEY = ['settings', 'cycle', 'drivers', 'api'];
module.exports.API_CONFIG = ['settings', 'api'];

/**
 * Creates an API path
 * @param {String} protocol. The protocol, such as 'http' or 'https'
 * @param {String} host. The host string, such as localhost, 127.0.0.1, or 'foo.co'
 * @param {String} port. The port number
 */
module.exports.apiUri = v(({protocol, host, port}) => `${protocol}://${host}:${port}`,
[
  ['api', PropTypes.shape({
    protocol: PropTypes.string.isRequired,
    host: PropTypes.string.isRequired,
    port: PropTypes.string.isRequired
  }).isRequired]
], 'apiUri');

 /**
  * TODO unused
 * Resolves something in a state object based on a path
 * @param {[String]} path. Array of path segments into the config up to the location of the current key
 * E.g. ['foo', 'bar', 1, 'marty'] to access the current entry 'something' in
 * {foo: { bar: [{}, {marty: {'something': {}}}] }}.
 * If the path does not
 * exist the functions throws, since this is an unacceptable coding or data config error.
 * @param {Object} state The current state of the application to be queried
 * @param {Object} context The context of request, such as a user's settings
 * For example,
 * @returns {Object} The matching current object or throws
const resolve = module.exports.resolve = v(R.curry((path, state, context) =>
  // Resolve the current entry
  reqPathThrowing(
    R.concat(
      path,
      // Resolve the current key
      reqPathThrowing(R.concat(path, ['current']), config)
    ),
    config)
),
[
  ['path', [Array]],
  ['config', [Object]],
], 'getCurrent');
*/

/**
 * Resolves some place in the config. The config is expected to have the normalized format of
 * Normalized format based on normalizr and json-api-normalizer formats
 * Given an example state with this format, where state is client side test, redux store, etc or delivered from a server
 * by an API to represent an external state:
 *
 * const state = {
 *  foo: {
 *    aFoo: {
 *      bars: [{id:'1'},{id:'2'},{id:'3'}]
*     },
 *    bFoo: {
 *      bars: [{id:'1'},{id: '3},...]
*     }
 *  }
 *  bar: {
 *    '1': {
 *      guitars: [{id: '1'}, ...]
 *    }
 *  }
 *  guitar: {...}
 * }
 * Above, foo and bar, guitar are entity names. They are only defined at the top level and must be referenced
 * in their singular form (no plurals). aFoo, bFoo, '1', '2', '3', are identifiers, where friendly strings
 * are used in json configurations and numerical strings are generated by databases, etc. Ids may be
 * used in configs, api returns, etc as keys to entity objects. Alternatively, entities may be represented
 * as arrays without keys, e.g. foo: { [{id: 'aFoo'}, {id: 'bFoo'}, ...] } instead.
 * Relationships must be represented by arrays, not objects or scalars, e.g. bar: [{id:'1'},{id:'2'},{id:'3'}]}
 * but not bar: {'1': {}, '2': {}, ...} nor bar: '1' or bar:{id: '1'}. It is the job of logic to limit
 * a relation to a toOne rather than a toMany.
 *
 * The sought place might be graphed by another object's current or selected values, for instance
 * an admin looking at user selections might have this:
 * const queryState {
 *  user: {
 *    marty: {
 *      foo: {
 *        selected: [
 *         {id: '1'
 *          bar: {
 *            highlighted: [
 *              {id: '1'}
 *            ]
 *          }
 *         },
 *         {id: '2'}
 *        ]
 *      }
 *    },
 *    timmy: {
 *    }
 *  }
 * }
 * This indicates that marty has selected foos with ids '1' and '2' and additionally highlighted
 * bar with id '1' in the context of the foo with id '1'.
 * If we have a function getPath(state, queryState, path)
 * To resolve marty's foo selections, path is ['marty', 'foo', 'selected']
 * resulting in the
 */

